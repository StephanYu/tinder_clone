// 1) Creating a Reference

new Firebase('https://docs-examples.firebaseio.com/web/data');

// 2) Accessing the child either directly via the URL or via the child API

var rootRef = new Firebase('https://docs-examples.firebaseio.com/web/data');
rootRef.child('users/mchen/name');

// 3) four methods for writing data to Firebase: set(), update(), push(), and our transaction 

  // set() which saves new data to the specified Firebase reference, replacing any existing data at that path
  // First, create a reference to user data. Then use set() to save a user object to Firebase
  var usersRef = ref.child("users");
  usersRef.set({
    alanisawesome: {
      date_of_birth: "June 23, 1912",
      full_name: "Alan Turing"
    },
    gracehop: {
      date_of_birth: "December 9, 1906",
      full_name: "Grace Hopper"
    }
  });

  // If you want to write to multiple children of a Firebase location at the same time without overwriting other child nodes, you can use the update() method 
  var hopperRef = usersRef.child("gracehop");
  hopperRef.update({
    "nickname": "Amazing Grace"
  }); 

  // If you'd like to know when your data has been committed, you can add a completion callback. Both set() and update() take an optional completion callback that is called when the write has been committed to the Firebase servers. If the call was unsuccessful for some reason, the callback will be passed an error object indicating why the failure occurred.

  dataRef.set("I'm writing data", function(error) {
    if (error) {
      alert("Data could not be saved." + error);
    } else {
      alert("Data saved successfully.");
    }
  });

  // Firebase provides a push() function that generates a unique ID every time a new child is added to the specified Firebase reference
  var postsRef = ref.child("posts");
  postsRef.push({
    author: "gracehop",
    title: "Announcing COBOL, a New Programming Language"
  });
  postsRef.push({
    author: "alanisawesome",
    title: "The Turing Machine"
  });

  // Calling push() will return a reference to the new data path, which you can use to get the value of its ID or set data to it. The following code will result in the same data as the above example, but now we'll have access to the unique push ID that was generated:
  // Generate a reference to a new location and add some data using push()
  var newPostRef = postsRef.push({
    author: "gracehop",
    title: "Announcing COBOL, a New Programming Language"
  });
  
  // Get the unique ID generated by push()
  var postID = newPostRef.name();


//READING Data
// Get a reference to our posts
var postsRef = new Firebase("https://docs-examples.firebaseio.com/web/saving-data/fireblog/posts");

// Attach an asynchronous callback to read the data at our posts reference
postsRef.on('value', function (snapshot) {
  console.log(snapshot.val());
}, function (errorObject) {
  console.log('The read failed: ' + errorObject.code);
});

// Value

// The value event is used to read a static snapshot of the contents at a given path, as they existed at the time of the read event. It is triggered once with the initial data and again every time the data changes.

// Child Added
// If we wanted to retrieve only the data on each new post added to our blogging app, we could use child_added:
// Get a reference to our posts
var postsRef = new Firebase("https://docs-examples.firebaseio.com/web/saving-data/fireblog/posts");

// Retrieve new posts as they are added to Firebase
postsRef.on('child_added', function (snapshot) {
  var newPost = snapshot.val();
  console.log("Author: " + newPost.author);
  console.log("Title: " + newPost.title);
});

// Child Changed

// The child_changed event is triggered any time a child node is modified. This includes any modifications to descendants of the child node.

// Child Removed

// The child_removed event is triggered when an immediate child is removed. 








